// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/network.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Vlan_CreateVLANRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parent interface name (e.g., "eth0")
  var parentInterface: String = String()

  /// VLAN ID (1-4094)
  var vlanID: UInt32 = 0

  /// IP address with CIDR notation (e.g., "172.18.0.5/16")
  /// If empty, no IP is configured
  var ipAddress: String = String()

  /// Gateway IP address (e.g., "172.18.0.1")
  /// If empty, no default route is added
  var gateway: String = String()

  /// Optional: Custom MAC address for the VLAN interface
  /// If empty, inherits parent's MAC
  var macAddress: String = String()

  /// Optional: MTU for the VLAN interface
  /// If 0, uses parent's MTU
  var mtu: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vlan_CreateVLANResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  var success: Bool = false

  /// Created interface name (e.g., "eth0.100")
  var interfaceName: String = String()

  /// Error message if success = false
  var error: String = String()

  /// Actual MAC address assigned
  var macAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vlan_DeleteVLANRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Interface name to delete (e.g., "eth0.100")
  var interfaceName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vlan_DeleteVLANResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  var success: Bool = false

  /// Error message if success = false
  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vlan_ConfigureIPRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Interface name (e.g., "eth0.100")
  var interfaceName: String = String()

  /// IP address with CIDR notation (e.g., "172.18.0.5/16")
  var ipAddress: String = String()

  /// If true, replaces all existing IPs on the interface
  /// If false, adds to existing IPs
  var replace: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vlan_ConfigureIPResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  var success: Bool = false

  /// Error message if success = false
  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vlan_AddRouteRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Destination network in CIDR notation (e.g., "0.0.0.0/0" for default route)
  /// Empty string means default route
  var destination: String = String()

  /// Gateway IP address
  var gateway: String = String()

  /// Interface name to route through (e.g., "eth0.100")
  var interfaceName: String = String()

  /// Route metric/priority (lower = higher priority)
  /// 0 = use system default
  var metric: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vlan_AddRouteResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  var success: Bool = false

  /// Error message if success = false
  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vlan_DeleteRouteRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Destination network in CIDR notation
  var destination: String = String()

  /// Gateway IP address (optional, for matching specific route)
  var gateway: String = String()

  /// Interface name (optional, for matching specific route)
  var interfaceName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vlan_DeleteRouteResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  var success: Bool = false

  /// Error message if success = false
  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vlan_ListInterfacesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional: Filter by interface name pattern
  var nameFilter: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vlan_ListInterfacesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of network interfaces
  var interfaces: [Vlan_NetworkInterface] = []

  /// Error message if retrieval failed
  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vlan_NetworkInterface: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Interface name (e.g., "eth0", "eth0.100")
  var name: String = String()

  /// Interface index
  var index: Int32 = 0

  /// MAC address
  var macAddress: String = String()

  /// MTU
  var mtu: UInt32 = 0

  /// List of IP addresses (CIDR notation)
  var ipAddresses: [String] = []

  /// Interface state (up/down)
  var isUp: Bool = false

  /// Parent interface for VLANs (empty if not a VLAN)
  var parent: String = String()

  /// VLAN ID (0 if not a VLAN)
  var vlanID: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "vlan"

extension Vlan_CreateVLANRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateVLANRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}parent_interface\0\u{3}vlan_id\0\u{3}ip_address\0\u{1}gateway\0\u{3}mac_address\0\u{1}mtu\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parentInterface) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.vlanID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ipAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.gateway) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.macAddress) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.mtu) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parentInterface.isEmpty {
      try visitor.visitSingularStringField(value: self.parentInterface, fieldNumber: 1)
    }
    if self.vlanID != 0 {
      try visitor.visitSingularUInt32Field(value: self.vlanID, fieldNumber: 2)
    }
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ipAddress, fieldNumber: 3)
    }
    if !self.gateway.isEmpty {
      try visitor.visitSingularStringField(value: self.gateway, fieldNumber: 4)
    }
    if !self.macAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.macAddress, fieldNumber: 5)
    }
    if self.mtu != 0 {
      try visitor.visitSingularUInt32Field(value: self.mtu, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vlan_CreateVLANRequest, rhs: Vlan_CreateVLANRequest) -> Bool {
    if lhs.parentInterface != rhs.parentInterface {return false}
    if lhs.vlanID != rhs.vlanID {return false}
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.gateway != rhs.gateway {return false}
    if lhs.macAddress != rhs.macAddress {return false}
    if lhs.mtu != rhs.mtu {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vlan_CreateVLANResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateVLANResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}interface_name\0\u{1}error\0\u{3}mac_address\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.interfaceName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.macAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.interfaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.interfaceName, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    if !self.macAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.macAddress, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vlan_CreateVLANResponse, rhs: Vlan_CreateVLANResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.interfaceName != rhs.interfaceName {return false}
    if lhs.error != rhs.error {return false}
    if lhs.macAddress != rhs.macAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vlan_DeleteVLANRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteVLANRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}interface_name\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.interfaceName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.interfaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.interfaceName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vlan_DeleteVLANRequest, rhs: Vlan_DeleteVLANRequest) -> Bool {
    if lhs.interfaceName != rhs.interfaceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vlan_DeleteVLANResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteVLANResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vlan_DeleteVLANResponse, rhs: Vlan_DeleteVLANResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vlan_ConfigureIPRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfigureIPRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}interface_name\0\u{3}ip_address\0\u{1}replace\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.interfaceName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ipAddress) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.replace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.interfaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.interfaceName, fieldNumber: 1)
    }
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ipAddress, fieldNumber: 2)
    }
    if self.replace != false {
      try visitor.visitSingularBoolField(value: self.replace, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vlan_ConfigureIPRequest, rhs: Vlan_ConfigureIPRequest) -> Bool {
    if lhs.interfaceName != rhs.interfaceName {return false}
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.replace != rhs.replace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vlan_ConfigureIPResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfigureIPResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vlan_ConfigureIPResponse, rhs: Vlan_ConfigureIPResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vlan_AddRouteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddRouteRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}destination\0\u{1}gateway\0\u{3}interface_name\0\u{1}metric\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.destination) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.gateway) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.interfaceName) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.metric) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 1)
    }
    if !self.gateway.isEmpty {
      try visitor.visitSingularStringField(value: self.gateway, fieldNumber: 2)
    }
    if !self.interfaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.interfaceName, fieldNumber: 3)
    }
    if self.metric != 0 {
      try visitor.visitSingularUInt32Field(value: self.metric, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vlan_AddRouteRequest, rhs: Vlan_AddRouteRequest) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.gateway != rhs.gateway {return false}
    if lhs.interfaceName != rhs.interfaceName {return false}
    if lhs.metric != rhs.metric {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vlan_AddRouteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddRouteResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vlan_AddRouteResponse, rhs: Vlan_AddRouteResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vlan_DeleteRouteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteRouteRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}destination\0\u{1}gateway\0\u{3}interface_name\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.destination) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.gateway) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.interfaceName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 1)
    }
    if !self.gateway.isEmpty {
      try visitor.visitSingularStringField(value: self.gateway, fieldNumber: 2)
    }
    if !self.interfaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.interfaceName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vlan_DeleteRouteRequest, rhs: Vlan_DeleteRouteRequest) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.gateway != rhs.gateway {return false}
    if lhs.interfaceName != rhs.interfaceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vlan_DeleteRouteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteRouteResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vlan_DeleteRouteResponse, rhs: Vlan_DeleteRouteResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vlan_ListInterfacesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListInterfacesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}name_filter\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nameFilter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nameFilter.isEmpty {
      try visitor.visitSingularStringField(value: self.nameFilter, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vlan_ListInterfacesRequest, rhs: Vlan_ListInterfacesRequest) -> Bool {
    if lhs.nameFilter != rhs.nameFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vlan_ListInterfacesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListInterfacesResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}interfaces\0\u{1}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.interfaces) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.interfaces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.interfaces, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vlan_ListInterfacesResponse, rhs: Vlan_ListInterfacesResponse) -> Bool {
    if lhs.interfaces != rhs.interfaces {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vlan_NetworkInterface: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkInterface"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}index\0\u{3}mac_address\0\u{1}mtu\0\u{3}ip_addresses\0\u{3}is_up\0\u{1}parent\0\u{3}vlan_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.macAddress) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.mtu) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.ipAddresses) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isUp) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.vlanID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 2)
    }
    if !self.macAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.macAddress, fieldNumber: 3)
    }
    if self.mtu != 0 {
      try visitor.visitSingularUInt32Field(value: self.mtu, fieldNumber: 4)
    }
    if !self.ipAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ipAddresses, fieldNumber: 5)
    }
    if self.isUp != false {
      try visitor.visitSingularBoolField(value: self.isUp, fieldNumber: 6)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 7)
    }
    if self.vlanID != 0 {
      try visitor.visitSingularUInt32Field(value: self.vlanID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vlan_NetworkInterface, rhs: Vlan_NetworkInterface) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.index != rhs.index {return false}
    if lhs.macAddress != rhs.macAddress {return false}
    if lhs.mtu != rhs.mtu {return false}
    if lhs.ipAddresses != rhs.ipAddresses {return false}
    if lhs.isUp != rhs.isUp {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.vlanID != rhs.vlanID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
