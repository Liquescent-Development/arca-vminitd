// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/tapforwarder.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Arca TAP Forwarder Control Plane Protocol
// gRPC API for dynamic network interface management in containers

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request to attach container to a network
struct Arca_Tapforwarder_V1_AttachNetworkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Network interface name (e.g., "eth0", "eth1")
  var device: String = String()

  /// vsock port for data plane (packet forwarding)
  var vsockPort: UInt32 = 0

  /// IP address to assign to this interface (e.g., "172.18.0.2")
  var ipAddress: String = String()

  /// Network gateway IP (e.g., "172.18.0.1")
  var gateway: String = String()

  /// Network mask in CIDR notation (e.g., 24 for /24)
  /// If not specified, defaults to /24
  var netmask: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arca_Tapforwarder_V1_AttachNetworkResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  var success: Bool = false

  /// Error message if success = false
  var error: String = String()

  /// MAC address assigned to the interface
  var macAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to detach container from a network
struct Arca_Tapforwarder_V1_DetachNetworkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Network interface name to remove (e.g., "eth0")
  var device: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arca_Tapforwarder_V1_DetachNetworkResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  var success: Bool = false

  /// Error message if success = false
  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to list all attached networks
struct Arca_Tapforwarder_V1_ListNetworksRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arca_Tapforwarder_V1_ListNetworksResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var networks: [Arca_Tapforwarder_V1_NetworkInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arca_Tapforwarder_V1_NetworkInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Interface name
  var device: String = String()

  /// IP address
  var ipAddress: String = String()

  /// Gateway
  var gateway: String = String()

  /// vsock port for data plane
  var vsockPort: UInt32 = 0

  /// MAC address
  var macAddress: String = String()

  /// Packet statistics
  var stats: Arca_Tapforwarder_V1_PacketStats {
    get {return _stats ?? Arca_Tapforwarder_V1_PacketStats()}
    set {_stats = newValue}
  }
  /// Returns true if `stats` has been explicitly set.
  var hasStats: Bool {return self._stats != nil}
  /// Clears the value of `stats`. Subsequent reads from it will return its default value.
  mutating func clearStats() {self._stats = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stats: Arca_Tapforwarder_V1_PacketStats? = nil
}

struct Arca_Tapforwarder_V1_PacketStats: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Packets sent (TAP -> vsock)
  var packetsSent: UInt64 = 0

  /// Packets received (vsock -> TAP)
  var packetsReceived: UInt64 = 0

  /// Bytes sent
  var bytesSent: UInt64 = 0

  /// Bytes received
  var bytesReceived: UInt64 = 0

  /// Send errors
  var sendErrors: UInt64 = 0

  /// Receive errors
  var receiveErrors: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request forwarder status
struct Arca_Tapforwarder_V1_GetStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arca_Tapforwarder_V1_GetStatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Forwarder version
  var version: String = String()

  /// Number of active network interfaces
  var activeNetworks: UInt32 = 0

  /// Uptime in seconds
  var uptimeSeconds: UInt64 = 0

  /// Overall packet statistics
  var totalStats: Arca_Tapforwarder_V1_PacketStats {
    get {return _totalStats ?? Arca_Tapforwarder_V1_PacketStats()}
    set {_totalStats = newValue}
  }
  /// Returns true if `totalStats` has been explicitly set.
  var hasTotalStats: Bool {return self._totalStats != nil}
  /// Clears the value of `totalStats`. Subsequent reads from it will return its default value.
  mutating func clearTotalStats() {self._totalStats = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _totalStats: Arca_Tapforwarder_V1_PacketStats? = nil
}

/// Request to update DNS mappings for network topology
struct Arca_Tapforwarder_V1_UpdateDNSMappingsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Complete network topology for this container
  /// Maps network name -> list of containers on that network
  var networks: Dictionary<String,Arca_Tapforwarder_V1_NetworkPeers> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arca_Tapforwarder_V1_NetworkPeers: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Containers on this network
  var containers: [Arca_Tapforwarder_V1_ContainerDNSInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arca_Tapforwarder_V1_ContainerDNSInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Container name (for DNS resolution)
  var name: String = String()

  /// Container ID (64-char Docker ID)
  var id: String = String()

  /// IP address on this network
  var ipAddress: String = String()

  /// Hostname aliases
  var aliases: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arca_Tapforwarder_V1_UpdateDNSMappingsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  var success: Bool = false

  /// Error message if success = false
  var error: String = String()

  /// Number of DNS records updated
  var recordsUpdated: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "arca.tapforwarder.v1"

extension Arca_Tapforwarder_V1_AttachNetworkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttachNetworkRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}device\0\u{3}vsock_port\0\u{3}ip_address\0\u{1}gateway\0\u{1}netmask\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.device) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.vsockPort) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ipAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.gateway) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.netmask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.device.isEmpty {
      try visitor.visitSingularStringField(value: self.device, fieldNumber: 1)
    }
    if self.vsockPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.vsockPort, fieldNumber: 2)
    }
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ipAddress, fieldNumber: 3)
    }
    if !self.gateway.isEmpty {
      try visitor.visitSingularStringField(value: self.gateway, fieldNumber: 4)
    }
    if self.netmask != 0 {
      try visitor.visitSingularUInt32Field(value: self.netmask, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arca_Tapforwarder_V1_AttachNetworkRequest, rhs: Arca_Tapforwarder_V1_AttachNetworkRequest) -> Bool {
    if lhs.device != rhs.device {return false}
    if lhs.vsockPort != rhs.vsockPort {return false}
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.gateway != rhs.gateway {return false}
    if lhs.netmask != rhs.netmask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Tapforwarder_V1_AttachNetworkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttachNetworkResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{3}mac_address\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.macAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if !self.macAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.macAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arca_Tapforwarder_V1_AttachNetworkResponse, rhs: Arca_Tapforwarder_V1_AttachNetworkResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.macAddress != rhs.macAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Tapforwarder_V1_DetachNetworkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DetachNetworkRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}device\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.device) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.device.isEmpty {
      try visitor.visitSingularStringField(value: self.device, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arca_Tapforwarder_V1_DetachNetworkRequest, rhs: Arca_Tapforwarder_V1_DetachNetworkRequest) -> Bool {
    if lhs.device != rhs.device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Tapforwarder_V1_DetachNetworkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DetachNetworkResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arca_Tapforwarder_V1_DetachNetworkResponse, rhs: Arca_Tapforwarder_V1_DetachNetworkResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Tapforwarder_V1_ListNetworksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListNetworksRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arca_Tapforwarder_V1_ListNetworksRequest, rhs: Arca_Tapforwarder_V1_ListNetworksRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Tapforwarder_V1_ListNetworksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListNetworksResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}networks\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.networks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.networks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.networks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arca_Tapforwarder_V1_ListNetworksResponse, rhs: Arca_Tapforwarder_V1_ListNetworksResponse) -> Bool {
    if lhs.networks != rhs.networks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Tapforwarder_V1_NetworkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}device\0\u{3}ip_address\0\u{1}gateway\0\u{3}vsock_port\0\u{3}mac_address\0\u{1}stats\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.device) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ipAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.gateway) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.vsockPort) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.macAddress) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.device.isEmpty {
      try visitor.visitSingularStringField(value: self.device, fieldNumber: 1)
    }
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ipAddress, fieldNumber: 2)
    }
    if !self.gateway.isEmpty {
      try visitor.visitSingularStringField(value: self.gateway, fieldNumber: 3)
    }
    if self.vsockPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.vsockPort, fieldNumber: 4)
    }
    if !self.macAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.macAddress, fieldNumber: 5)
    }
    try { if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arca_Tapforwarder_V1_NetworkInfo, rhs: Arca_Tapforwarder_V1_NetworkInfo) -> Bool {
    if lhs.device != rhs.device {return false}
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.gateway != rhs.gateway {return false}
    if lhs.vsockPort != rhs.vsockPort {return false}
    if lhs.macAddress != rhs.macAddress {return false}
    if lhs._stats != rhs._stats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Tapforwarder_V1_PacketStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PacketStats"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}packets_sent\0\u{3}packets_received\0\u{3}bytes_sent\0\u{3}bytes_received\0\u{3}send_errors\0\u{3}receive_errors\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.packetsSent) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.packetsReceived) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.bytesSent) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.bytesReceived) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.sendErrors) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.receiveErrors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.packetsSent != 0 {
      try visitor.visitSingularUInt64Field(value: self.packetsSent, fieldNumber: 1)
    }
    if self.packetsReceived != 0 {
      try visitor.visitSingularUInt64Field(value: self.packetsReceived, fieldNumber: 2)
    }
    if self.bytesSent != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesSent, fieldNumber: 3)
    }
    if self.bytesReceived != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesReceived, fieldNumber: 4)
    }
    if self.sendErrors != 0 {
      try visitor.visitSingularUInt64Field(value: self.sendErrors, fieldNumber: 5)
    }
    if self.receiveErrors != 0 {
      try visitor.visitSingularUInt64Field(value: self.receiveErrors, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arca_Tapforwarder_V1_PacketStats, rhs: Arca_Tapforwarder_V1_PacketStats) -> Bool {
    if lhs.packetsSent != rhs.packetsSent {return false}
    if lhs.packetsReceived != rhs.packetsReceived {return false}
    if lhs.bytesSent != rhs.bytesSent {return false}
    if lhs.bytesReceived != rhs.bytesReceived {return false}
    if lhs.sendErrors != rhs.sendErrors {return false}
    if lhs.receiveErrors != rhs.receiveErrors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Tapforwarder_V1_GetStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetStatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arca_Tapforwarder_V1_GetStatusRequest, rhs: Arca_Tapforwarder_V1_GetStatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Tapforwarder_V1_GetStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetStatusResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{3}active_networks\0\u{3}uptime_seconds\0\u{3}total_stats\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.activeNetworks) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.uptimeSeconds) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._totalStats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if self.activeNetworks != 0 {
      try visitor.visitSingularUInt32Field(value: self.activeNetworks, fieldNumber: 2)
    }
    if self.uptimeSeconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.uptimeSeconds, fieldNumber: 3)
    }
    try { if let v = self._totalStats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arca_Tapforwarder_V1_GetStatusResponse, rhs: Arca_Tapforwarder_V1_GetStatusResponse) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.activeNetworks != rhs.activeNetworks {return false}
    if lhs.uptimeSeconds != rhs.uptimeSeconds {return false}
    if lhs._totalStats != rhs._totalStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Tapforwarder_V1_UpdateDNSMappingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateDNSMappingsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}networks\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Arca_Tapforwarder_V1_NetworkPeers>.self, value: &self.networks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.networks.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Arca_Tapforwarder_V1_NetworkPeers>.self, value: self.networks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arca_Tapforwarder_V1_UpdateDNSMappingsRequest, rhs: Arca_Tapforwarder_V1_UpdateDNSMappingsRequest) -> Bool {
    if lhs.networks != rhs.networks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Tapforwarder_V1_NetworkPeers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkPeers"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}containers\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.containers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.containers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arca_Tapforwarder_V1_NetworkPeers, rhs: Arca_Tapforwarder_V1_NetworkPeers) -> Bool {
    if lhs.containers != rhs.containers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Tapforwarder_V1_ContainerDNSInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerDNSInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}id\0\u{3}ip_address\0\u{1}aliases\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ipAddress) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.aliases) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ipAddress, fieldNumber: 3)
    }
    if !self.aliases.isEmpty {
      try visitor.visitRepeatedStringField(value: self.aliases, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arca_Tapforwarder_V1_ContainerDNSInfo, rhs: Arca_Tapforwarder_V1_ContainerDNSInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.id != rhs.id {return false}
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.aliases != rhs.aliases {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Tapforwarder_V1_UpdateDNSMappingsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateDNSMappingsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{3}records_updated\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.recordsUpdated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if self.recordsUpdated != 0 {
      try visitor.visitSingularUInt32Field(value: self.recordsUpdated, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arca_Tapforwarder_V1_UpdateDNSMappingsResponse, rhs: Arca_Tapforwarder_V1_UpdateDNSMappingsResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.recordsUpdated != rhs.recordsUpdated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
